{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ca96f978",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import warnings\n",
    "import re\n",
    "warnings.filterwarnings('ignore')\n",
    "import os\n",
    "import gradio as gr\n",
    "from dotenv import load_dotenv\n",
    "from langchain.chat_models import ChatOpenAI\n",
    "from langchain.vectorstores import FAISS\n",
    "from langchain.embeddings import HuggingFaceEmbeddings\n",
    "from langchain.prompts import PromptTemplate\n",
    "from langchain.schema import Document\n",
    "import json\n",
    "import openai\n",
    "import asyncio\n",
    "from langchain.agents import Tool, initialize_agent\n",
    "from langchain.memory import ConversationBufferMemory\n",
    "from langchain.document_loaders import DataFrameLoader\n",
    "\n",
    "# Assuming the previous chatbot setup is correct\n",
    "# Set up the embeddings, vector store, tools, agent, etc.\n",
    "api_key = os.getenv('OPENAI_API_KEY')  \n",
    "\n",
    "def load_json_file(file_path):\n",
    "    data = []\n",
    "    with open(file_path, 'r') as f:\n",
    "        for line in f:\n",
    "            try:\n",
    "                data.append(json.loads(line))\n",
    "            except json.JSONDecodeError as e:\n",
    "                print(f\"Skipping invalid JSON line: {line.strip()} due to error: {e}\")\n",
    "    return data\n",
    "\n",
    "# Load Q&A and review data\n",
    "qa_data = load_json_file(\"qa_Appliances.json\")\n",
    "review_data = load_json_file(\"app1.json\")\n",
    "qa_cust=pd.read_csv('./qaecomm.csv')\n",
    "qa_cust[\"text\"] = qa_cust[\"question\"] + \" \" + qa_cust[\"answers\"]\n",
    "loader = DataFrameLoader(qa_cust, page_content_column=\"text\")\n",
    "qacust_documents = loader.load()\n",
    "\n",
    "# Prepare documents\n",
    "def prepare_documents_qa(data):\n",
    "    documents = []\n",
    "    for item in data:\n",
    "        content = f\"Question: {item['question']} Answer: {item['answer']}\"\n",
    "        metadata = {\"asin\": item.get(\"asin\"), \"questionType\": item.get(\"questionType\")}\n",
    "        documents.append(Document(page_content=content, metadata=metadata))\n",
    "    return documents\n",
    "\n",
    "def prepare_documents_reviews(data):\n",
    "    documents = []\n",
    "    for item in data:\n",
    "        content = f\"Title: {item['title']} Review: {item['text']}\"\n",
    "        metadata = {\"asin\": item.get(\"asin\"), \"rating\": item.get(\"rating\")}\n",
    "        documents.append(Document(page_content=content, metadata=metadata))\n",
    "    return documents\n",
    "\n",
    "qa_documents = prepare_documents_qa(qa_data)\n",
    "review_documents = prepare_documents_reviews(review_data)\n",
    "\n",
    "# Create Vector Store\n",
    "embeddings = HuggingFaceEmbeddings(model_name=\"sentence-transformers/all-MiniLM-L6-v2\")\n",
    "\n",
    "qa_vectorstore = FAISS.from_documents(qa_documents, embeddings)\n",
    "reviews_vectorstore = FAISS.from_documents(review_documents, embeddings)\n",
    "qacust_vectorstore = FAISS.from_documents(qacust_documents, embeddings)\n",
    "\n",
    "def retrieve_from_qa(query: str):\n",
    "    docs = qa_vectorstore.similarity_search(query, k=3)\n",
    "    return \"\\n\".join([doc.page_content for doc in docs])\n",
    "\n",
    "\n",
    "# Async Retrieval for Efficiency\n",
    "async def async_retrieve_from_vectorstore(vectorstore, query, k=3):\n",
    "    \"\"\"Retrieve documents asynchronously from the vector store.\"\"\"\n",
    "    return vectorstore.similarity_search(query, k=k)\n",
    "\n",
    "async def retrieve_all(query):\n",
    "    \"\"\"Retrieve from all vector stores in parallel.\"\"\"\n",
    "    qa_task = async_retrieve_from_vectorstore(qa_vectorstore, query)\n",
    "    reviews_task = async_retrieve_from_vectorstore(reviews_vectorstore, query)\n",
    "    customers_task = async_retrieve_from_vectorstore(qacust_vectorstore, query)\n",
    "    qa_docs, review_docs, customer_docs = await asyncio.gather(qa_task, reviews_task, customers_task)\n",
    "    return qa_docs, review_docs, customer_docs\n",
    "\n",
    "# Define Retrieval Functions\n",
    "def preprocess_query(query: str) -> str:\n",
    "    \"\"\"Refine user query for better vector store matching.\"\"\"\n",
    "    # Optional: Apply transformations like stemming, keyword extraction, etc.\n",
    "    return query.lower().strip()\n",
    "\n",
    "def retrieve_from_qa(query: str):\n",
    "    query = preprocess_query(query)\n",
    "    docs = qa_vectorstore.similarity_search(query, k=5)  # Experiment with k\n",
    "    if not docs:\n",
    "        return \"No relevant Q&A information found. Please refine your query.\"\n",
    "    return \"\\n\".join([doc.page_content for doc in docs])\n",
    "\n",
    "def retrieve_from_reviews(query: str):\n",
    "    query = preprocess_query(query)\n",
    "    docs = reviews_vectorstore.similarity_search(query, k=5)  # Experiment with k\n",
    "    if not docs:\n",
    "        return \"No relevant reviews found. Please refine your query.\"\n",
    "    return \"\\n\".join([doc.page_content for doc in docs])\n",
    "\n",
    "def retrieve_answer(query: str):\n",
    "    query = preprocess_query(query)\n",
    "    docs = qacust_vectorstore.similarity_search(query, k=5)  # Experiment with k\n",
    "    if not docs:\n",
    "        return \"No relevant customer support information found. Please refine your query.\"\n",
    "    return \"\\n\".join([doc.page_content for doc in docs])\n",
    "\n",
    "# Define Tools\n",
    "tools = [\n",
    "    Tool(\n",
    "        name=\"Product Q&A\",\n",
    "        func=retrieve_from_qa,\n",
    "        description=\"Fetch information from the Q&A knowledge base for specific product-related questions.\"\n",
    "    ),\n",
    "    Tool(\n",
    "        name=\"Product Reviews\",\n",
    "        func=retrieve_from_reviews,\n",
    "        description=\"Fetch product reviews and customer feedback.\"\n",
    "    ),\n",
    "    Tool(\n",
    "        name=\"Customers Q&A\",\n",
    "        func=retrieve_answer,\n",
    "        description=\"Fetch information from the customer support Q&A knowledge base for general customer queries.\"\n",
    "    ),\n",
    "]\n",
    "\n",
    "# Chat Model and Agent\n",
    "llm = ChatOpenAI(model=\"gpt-3.5-turbo\", temperature=0)\n",
    "memory = ConversationBufferMemory(memory_key=\"chat_history\", return_messages=True)\n",
    "\n",
    "# Updated Prompt\n",
    "prompt_template = \"\"\"\n",
    "You are a friendly and helpful customer support assistant for an e-commerce platform.\n",
    "1. Always greet customers warmly at the beginning of the conversation or when they say \"hi,\" \"hello,\" etc.\n",
    "2. Use a warm and empathetic tone in your responses.\n",
    "3. Use one of the tools to answer queries if they are product-related or related to reviews and customer support.\n",
    "4. If a query is unrelated to the tools, respond politely that it is outside your scope.\n",
    "5. Avoid generic or robotic-sounding replies.\n",
    "\n",
    "1.Thank You for contacting &quot;ChatBot Help You&quot; ! How may I assist you today?\n",
    "2.Good day,This is &quot;Chatbot Help You&quot;. Let me know how I can help you!\n",
    "3.“Hello! Thank you for reaching out to us!How can I assist you today?”\n",
    "4.“Please feel free to share any questions or concerns you have—I’m happy to help!”\n",
    "\n",
    "\n",
    "If a query cannot be answered:\n",
    "\"I’m sorry, but that question is outside my scope. Let me know if there’s anything else I can help you with.\"\n",
    "\n",
    "1. Use your tools to provide accurate answers based on specific customer queries:\n",
    "   - \"Product Q&A\" for product-related questions.\n",
    "   - \"Product Reviews\" for customer feedback on products.\n",
    "   - \"Customers Q&A\" for general customer support inquiries.\n",
    "2. If no relevant information is found, politely inform the user and suggest refining the query.\n",
    "3. Avoid answering questions outside the tools' scope.\n",
    "\n",
    "Example Scenarios:\n",
    "- Greeting: If the user says \"Hi,\" respond: \"Hello! Welcome to our support service. How can I help you today?\"\n",
    "- Out-of-scope queries: Respond: \"I'm sorry, but I can only assist with product-related or customer support questions.\"\n",
    "\n",
    "Query: {input}\n",
    "Thought: Analyze the query to determine which tool or response is most appropriate.\n",
    "Action: Choose a tool or provide a response.\n",
    "Observation: Review the retrieved information.\n",
    "Final Answer: Provide a clear and concise response to the customer.\n",
    "\n",
    "{tools}\n",
    "\"\"\"\n",
    "\n",
    "prompt = PromptTemplate(input_variables=[\"input\", \"tools\"], template=prompt_template)\n",
    "agent = initialize_agent(tools=tools, llm=llm, agent=\"zero-shot-react-description\", verbose=True, memory=memory)\n",
    "\n",
    "# Timer setup\n",
    "class ChatSession:\n",
    "    def __init__(self, timeout=120):\n",
    "        self.timeout = timeout  # In seconds\n",
    "        self.last_active = time()\n",
    "        self.session_active = True\n",
    "        self.timer_thread = threading.Thread(target=self.monitor_inactivity)\n",
    "        self.timer_thread.daemon = True\n",
    "        self.timer_thread.start()\n",
    "\n",
    "    def update_activity(self):\n",
    "        \"\"\"Reset the activity timer whenever the user interacts.\"\"\"\n",
    "        self.last_active = time()\n",
    "\n",
    "    def monitor_inactivity(self):\n",
    "        \"\"\"End session if inactive for too long.\"\"\"\n",
    "        while self.session_active:\n",
    "            if time() - self.last_active > self.timeout:\n",
    "                self.session_active = False\n",
    "                break\n",
    "            sleep(1)\n",
    "\n",
    "    def end_session_message(self):\n",
    "        \"\"\"Return a message when the session ends due to inactivity.\"\"\"\n",
    "        return \"The session has ended due to inactivity. Please start a new session if you need further assistance.\"\n",
    "\n",
    "# Create a Gradio Interface\n",
    "chat_session = ChatSession(timeout=120)  # 2-minute inactivity timeout\n",
    "\n",
    "# Chatbot logic\n",
    "def chatbot_response(user_input, chat_history=[]):\n",
    "    if not chat_session.session_active:\n",
    "        return chat_session.end_session_message(), []\n",
    "\n",
    "    if user_input.strip():\n",
    "        chat_session.update_activity()  # Reset timer\n",
    "        response = agent.run(user_input)\n",
    "        chat_history.append((\"You\", user_input))\n",
    "        chat_history.append((\"ChatBot\", response))\n",
    "        return response, chat_history\n",
    "    else:\n",
    "        return \"Please type something to continue.\", chat_history\n",
    "\n",
    "# Gradio interface\n",
    "with gr.Blocks() as chatbot_ui:\n",
    "    gr.Markdown(\"# Welcome to 'ChatBot Help You!'\")\n",
    "    \n",
    "    with gr.Row():\n",
    "        chatbot_input = gr.Textbox(placeholder=\"Type your message here...\")\n",
    "        chatbot_output = gr.Chatbot()\n",
    "    \n",
    "    inactivity_feedback = gr.Textbox(value=\"Session active.\", interactive=False, label=\"Session Status\")\n",
    "    timeout_slider = gr.Slider(minimum=60, maximum=300, value=120, step=10, label=\"Set Timeout (seconds)\")\n",
    "    \n",
    "    chat_history = gr.State([])\n",
    "    \n",
    "    with gr.Row():\n",
    "        submit_btn = gr.Button(\"Submit\")\n",
    "        reset_btn = gr.Button(\"Reset Session\")\n",
    "    \n",
    "    submit_btn.click(\n",
    "        chatbot_response,\n",
    "        inputs=[chatbot_input, chat_history, timeout_slider],\n",
    "        outputs=[chatbot_output, chat_history],\n",
    "    )\n",
    "    \n",
    "    submit_btn.click(\n",
    "        lambda: chat_session.end_session_message(), inputs=[], outputs=[inactivity_feedback]\n",
    "    )\n",
    "    \n",
    "    reset_btn.click(\n",
    "        reset_session,\n",
    "        inputs=[chat_history],\n",
    "        outputs=[chatbot_output, chat_history],\n",
    "    )\n",
    "    \n",
    "    reset_btn.click(\n",
    "        lambda: chat_session.reset_session() or \"Session reset. Active now.\", \n",
    "        inputs=[], \n",
    "        outputs=[inactivity_feedback]\n",
    "    )\n",
    "\n",
    "# Launch the app\n",
    "chatbot_ui.launch()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
